Always prioritize readability over brevity. Write clear, descriptive code that is easy to understand and maintain.

Apply SOLID principles:
- Single Responsibility: Each class/function should have one reason to change
- Open/Closed: Open for extension, closed for modification
- Liskov Substitution: Derived classes must be substitutable for base classes
- Interface Segregation: Many specific interfaces are better than one general-purpose interface
- Dependency Inversion: Depend on abstractions, not concretions

Use established design patterns when appropriate (Factory, Strategy, Observer, Builder, etc.). Choose patterns that solve the specific problem at hand.

Keep solutions minimalistic but readable. Avoid over-engineering while maintaining code clarity.

Use descriptive variable and function names. Write self-documenting code with meaningful comments for complex logic.

Break complex problems into smaller, focused functions. Create clear interfaces and abstractions.

Handle errors gracefully with clear error messages and appropriate exception types.

Structure code with proper separation of concerns. Avoid deep nesting and long functions.

Always validate inputs and provide meaningful feedback to users.